[
  
  {
    "title": "Path conflict detection in C++ using a trie-based algorithm",
    "url": "/posts/path-conflict-detection-in-cpp-using-a-trie-based-algorithm/",
    "categories": "Filesystem, Tree-Based Algorithms",
    "tags": "c++, c++17, trie, tree-algorithm, std-filesystem, path, conflict-detection, configuration-validation, unordered_map, lexically_normal, json, has_conflict",
    "date": "2025-04-23 00:00:00 +0200",
    





    
    "snippet": "IntroductionI am currently working on a tool that copies or moves specific directories on the file system. These directories are defined in a JSON file, which contains a list of source and destinat...",
    "content": "IntroductionI am currently working on a tool that copies or moves specific directories on the file system. These directories are defined in a JSON file, which contains a list of source and destination paths to be processed in order.However, when more than one path is configured, a possible problem can occur: two paths might overlap. For example, if /a/b and /a/b/c are both listed as sources, it is unclear what should happen if one is moved before the other. This can lead to inconsistent behavior or even data loss, especially when moving files.To detect such conflicts reliably, I wrote a function that stores all paths in a simple tree structure and checks whether a new path overlaps with an existing one. In this article, I show how this function works and why it has proven useful in practice.The Trie StructureTo efficiently check for overlapping paths, they are stored in a tree structure – more precisely, in a trie. Each node in the trie represents a single directory name, that is, one path component. This allows each path to be built step by step by inserting its components one after another into the tree.The structure of a node is kept simple:struct path_node {  std::unordered_map&lt;std::string, path_node&gt; children{};  bool is_terminal{false};};  children contains all child nodes – that is, the subdirectories of the current node.  is_terminal marks whether a complete path ends at this point.When a new path is inserted, all components are traversed – for example a, b, c – and the trie is updated accordingly: if a child node already exists, it is followed; otherwise, a new node is created.The code for that looks like this:auto [child, _] = current_node-&gt;children.try_emplace(/* path component */);current_node = &amp;child-&gt;second;try_emplace inserts the new node only if it does not already exist – otherwise, it simply returns the existing one. In both cases, current_node then points to the correct child node. This way, the path is built step by step inside the trie.With this structure in place, it is now possible to reliably detect whether a new path is part of an existing path, contains an existing path, or is identical to one.How paths are traversedBefore we get to the examples, I want to briefly explain how std::filesystem::path behaves – especially how a path is split into individual components.When a path like /a/b is traversed in a loopfor (auto const&amp; directory : path) { ... }the iterator yields each path component separately – in this case:/  (root)abThis is important because the conflict check is based exactly on this structure: each of these components is handled and stored separately in the trie. This is the only way to reliably detect whether a path already exists or overlaps with another one.Conflict Detection ExamplesThe following section shows how conflict detection works in detail using concrete path examples. Each case represents a typical situation that can occur in a configuration.Step by step, these examples build up the logic behind the has_conflict function – starting from simple cases and gradually covering all necessary checks.Example 1: A simple path (/a/b)The path /a/b is the first one to be inserted – the trie is still empty. The nodes a and then b are created step by step, and b is marked as terminal at the end.No conflict can occur at this point. This case shows the base state: paths are added without interfering with anything.namespace fs = std::filesystem;auto has_conflict(path_node&amp; root_node, fs::path const&amp; path) -&gt; bool {  path_node* current_node = &amp;root_node;  for (auto const&amp; directory : path) {    auto [child, _] = current_node-&gt;children.try_emplace(directory.string());    current_node = &amp;child-&gt;second;  }  current_node-&gt;is_terminal = true;  return false;}Example 2: A longer path below an existing one (/a/b/c)In this case, the path /a/b is already stored in the trie and marked as terminal. When trying to insert /a/b/c, the function detects at node b that a complete path already ends here.This means the new path lies underneath an existing one – a clear conflict.namespace fs = std::filesystem;auto has_conflict(path_node&amp; root_node, fs::path const&amp; path) -&gt; bool {  path_node* current_node = &amp;root_node;  for (auto const&amp; directory : path) {    if (current_node-&gt;is_terminal) { return true; }    auto [child, _] = current_node-&gt;children.try_emplace(directory.string());    current_node = &amp;child-&gt;second;  }  current_node-&gt;is_terminal = true;  return false;}Example 3: The same path again (/a/b)If the same path is inserted again, the function recognizes at the end that b is already marked as a terminal path. This is also treated as a conflict – duplicate entries must be prevented.namespace fs = std::filesystem;auto has_conflict(path_node&amp; root_node, fs::path const&amp; path) -&gt; bool {  path_node* current_node = &amp;root_node;  for (auto const&amp; directory : path) {    if (current_node-&gt;is_terminal) { return true; }    auto [child, _] = current_node-&gt;children.try_emplace(directory.string());    current_node = &amp;child-&gt;second;  }  if (current_node-&gt;is_terminal) {     return true;   }    current_node-&gt;is_terminal = true;  return false;}Example 4: A shorter path (/a) after /a/b already existsHere, the function tries to insert /a even though /a/b is already present. This also results in a conflict, because /a is a prefix of an existing path. The function detects this by checking whether node a already has child nodes.namespace fs = std::filesystem;namespace rng = std::ranges;auto has_conflict(path_node&amp; root_node, fs::path const&amp; path) -&gt; bool {  path_node* current_node = &amp;root_node;  for (auto const&amp; directory : path) {    if (current_node-&gt;is_terminal) { return true; }    auto [child, _] = current_node-&gt;children.try_emplace(directory.string());    current_node = &amp;child-&gt;second;  }  if (current_node-&gt;is_terminal || !rng::empty(current_node-&gt;children)) {     return true;   }    current_node-&gt;is_terminal = true;  return false;}The final versionnamespace fs = std::filesystem;namespace rng = std::ranges;auto has_conflict(path_node&amp; root_node, fs::path const&amp; path) -&gt; bool {  path_node* current_node = &amp;root_node;  for (auto const&amp; directory : path.lexically_normal()) {    if (directory.empty()) { break; }    if (current_node-&gt;is_terminal) { return true; }    auto [child, _] = current_node-&gt;children.try_emplace(directory.string());    current_node = &amp;child-&gt;second;  }  if (current_node-&gt;is_terminal || !rng::empty(current_node-&gt;children)) {     return true;   }    current_node-&gt;is_terminal = true;  return false;}This version includes all necessary checks to ensure consistent and conflict-free handling of paths. Two additional details make the function more robust in practice:lexically_normal()This version uses lexically_normal(). The reason: paths like a/./b/../b/c contain components such as . (current directory) and .. (parent directory), which are otherwise processed literally when iterated:a.b..bcWithout normalization, the path would not be recognized as what it actually is – namely a/b/c. The conflict check would become unreliable or incorrect.lexically_normal() ensures that such paths are cleaned up before being processed.directory.empty()Another technical detail: paths like /a/b/ end with a slash. This would result in an empty component when iterated:ab\"\"The lineif (directory.empty()) { break; }prevents such empty components from being added to the trie. Without this check, paths like /a/b and /a/b/ would be treated as different, even though they refer to the same location.ConclusionThe has_conflict function is not a complex algorithm, but it solves a concrete problem reliably. The trie structure allows each path to be represented in a structured, component-based way, which makes it easy to detect conflicts early.In my use case, the function has proven to be solid and flexible. It works regardless of whether a path is longer, shorter, or identical to an existing one – and it can easily be adapted to other scenarios where path overlaps need to be avoided.  Project Note: The has_conflict function is part of dropclone – a C++ tool for automated directory synchronization.  The project is still under development and available here:  ↪ GitHub link to dropclone.Share your feedbackPraise or criticism is appreciated!"
  },
  
  {
    "title": "A Constexpr-Compatible Algorithm for std::tuple - Part 2: tuple_find",
    "url": "/posts/implementing-tuple-find-a-constexpr-compatible-algorithm-for-heterogeneous-containers/",
    "categories": "Compile-time programming, Algorithms for Heterogeneous Containers",
    "tags": "c++, constexpr, compile-time, lambda, tuple, std-tuple, algorithms, heterogeneous-containers, tuple-for-each, tuple-find, std-apply, fold-expressions, parameter-pack, variadic-template, comma-operator, value-category, static_assert, reference-wrapper, std-variant, std-optional, index-sequence",
    "date": "2025-03-24 00:00:00 +0100",
    





    
    "snippet": "IntroductionIn the first part of this article series, an algorithm called tuple_for_each was introduced, enabling iteration over all elements of a std::tuple and applying an action to each one - wi...",
    "content": "IntroductionIn the first part of this article series, an algorithm called tuple_for_each was introduced, enabling iteration over all elements of a std::tuple and applying an action to each one - without relying on classic loops or iterators. Based on that foundation, this second article covers another common use case for heterogeneous containers: searching for a specific value.In standard containers like std::vector, this task is typically solved using std::find or std::ranges::find. For std::tuple, however, no such equivalent exists. This article closes that gap by explaining step by step how such a function can be implemented.The algorithm tuple_find looks for the first element in the tuple that matches a given value. It returns a reference to that element along with its position. The returned position allows the search to continue at that exact point in a later call, so additional matches can be found.At the same time, it takes into account whether the found element is a const or a modifiable reference. To represent this difference, the result is wrapped in a std::variant. Combined with std::optional, this also indicates whether a matching element was found at all.Unlike standard search functions, tuple_find must handle some specific challenges related to type safety and reference semantics in C++. These challenges and the resulting design decisions are the main focus of this article.Iteration with Index: Accessing Elements and PositionsAs already shown in tuple_for_each, iterating over a std::tuple requires a parameter pack. This is achieved by combining std::apply with a lambda function using variadic template parameters:template &lt;typename tuple_t, std::equality_comparable value_t&gt;constexpr auto tuple_find(tuple_t&amp;&amp; tuple, value_t const&amp; value, size_t index = 0) noexcept {  ...  return std::apply([&amp;](auto&amp;&amp;... tuple_values) {    ...  }, std::forward&lt;tuple_t&gt;(tuple));  ...}  Note: This technique for unpacking a tuple using std::apply and variadic lambdas is explained in detail in Part 1 of this series.However, for tuple_find, accessing the elements alone is not enough — we also need to know the position of each element within the tuple.This is essential to resume the search from a given point or to return the position of a match.To achieve this, we use std::make_index_sequence&lt;N&gt;, where N is the number of elements in the tuple:std::make_index_sequence&lt;std::tuple_size&lt;std::remove_cvref_t&lt;tuple_t&gt;&gt;{}&gt;{}This creates an object of type std::index_sequence&lt;0, 1, 2, ..., N-1&gt; at compile time. We then pass it to a lambda function with a deducible variadic template parameter for the indices:[&amp;]&lt;size_t... idx&gt;(std::index_sequence&lt;idx...&gt;) {  // Access to the indices: idx...}The indices idx... are automatically deduced from the std::index_sequence object during the call. Inside the lambda, they are available as a parameter pack — synchronized with the parameter pack of the tuple values.This creates an explicit mapping between each individual tuple element and its position - the foundation for further processing:template &lt;typename tuple_t, std::equality_comparable value_t&gt;constexpr auto tuple_find(tuple_t&amp;&amp; tuple, value_t const&amp; value, size_t index = 0) noexcept {  return [&amp;]&lt;size_t... idx&gt;(std::index_sequence&lt;idx...&gt;) {    return std::apply([&amp;](auto&amp;&amp;... tuple_values) {      ...    }, std::forward&lt;tuple_t&gt;(tuple));  }(std::make_index_sequence&lt;std::tuple_size&lt;std::remove_cvref_t&lt;tuple_t&gt;&gt;{}&gt;{});}Ensuring Reference ValiditySince tuple_find returns a reference to the found element, it must be ensured that this reference remains valid after the function call. A static_assert checks that all elements of the given tuple are Lvalue references:static_assert(((std::is_lvalue_reference_v&lt;decltype(tuple_values)&gt;) &amp;&amp; ...),  \"Error: All tuple elements must be lvalue references to ensure that returned \"  \"references remain valid.\");This prevents returning references to temporary objects. A typical example of such an error is caught at compile time:auto&amp; result = tuple_find(std::tuple{5.5, 10, \"str\", 20, 'c', 5, 10, 10.0}, 10);In this case, result would be a dangling reference, since the temporary std::tuple — and all its elements — are destroyed immediately after the function call.Reference Types and Return ValueSince tuple_find returns a reference to the matched element, it’s important to distinguish whether this reference is const or modifiable. However, this information is only available at the time a match is found.The search itself takes place - just like in tuple_for_each - inside a fold expression using the comma operator. Such an expansion cannot be exited early. Therefore, any potential match must be stored immediately in a suitable data structure, even though the fold expression continues afterward.This requirement makes it necessary to fully declare the return type before the search begins. Since the reference type (const or not) is still unknown at this point, we use std::variant to store either a const or non-const reference. To additionally signal whether a match was found, std::variant is combined with std::optional:std::optional&lt;std::variant&lt;non_const_result, const_result&gt;&gt;The reference is stored using std::reference_wrapper, because a std::pair does not allow assignment when one of its elements is of type const&amp;. Such an assignment is required inside the fold expression. std::reference_wrapper circumvents this limitation and makes the assignment possible.Fold Expression: Type Check and ComparisonAt the beginning of the fold expression, a type check is performed:([&amp;] {  if constexpr (std::is_same_v&lt;std::remove_cvref_t&lt;decltype(tuple_values)&gt;, value_t&gt;) {    // Comparison goes here  }}(), ...);Only elements whose type exactly matches the type of the search value are included in the comparison. This restriction is a direct result of how the function is structured: the return type must be defined before the iteration over the tuple begins. Since it is declared based on value_t, this is the only type that can be used for a valid reference return. Therefore, the comparison is explicitly limited to elements of this exact type.Since the function returns a reference to the found element, an exact type match is required—otherwise, no valid binding would be possible. For example, an int element cannot be returned as a long&amp;.Because a fold expression cannot be exited early, any match must be stored immediately in a previously defined data structure. The comparison is therefore performed only on elements where the types are guaranteed to match.Thanks to the previously constructed mapping between tuple elements and their positions (via std::index_sequence), each element also has a corresponding index. This allows the search to be started from a specific position within the tuple.if (!result &amp;&amp; idx &gt;= index &amp;&amp; std::equal_to{}(value, tuple_values)) {  ...}This checks whether an element matches the search value and whether it appears at or after the specified start index. Only if both conditions are met and no previous match has been recorded, the result is stored.Since the matched element might be either const or modifiable, the storage is handled accordingly:if constexpr (std::is_const_v&lt;std::remove_reference_t&lt;decltype(tuple_values)&gt;&gt;) {  result = result_t{std::in_place, const_result_t{tuple_values, idx}};} else {  result = result_t{std::in_place, non_const_result_t{tuple_values, idx}};}This ensures that the return value reflects both the correct reference type (const or not) and the element’s position within the tuple.Complete Functiontemplate &lt;typename tuple_t, std::equality_comparable value_t&gt;constexpr auto tuple_find(tuple_t&amp;&amp; tuple, value_t const&amp; value, size_t index = 0) noexcept {  return [&amp;]&lt;size_t... idx&gt;(std::index_sequence&lt;idx...&gt;) {    return std::apply([&amp;](auto&amp;&amp;... tuple_values) {      static_assert(((std::is_lvalue_reference_v&lt;decltype(tuple_values)&gt;) &amp;&amp; ...) ,        \"Error: All tuple elements must be lvalue references to ensure that returned \"        \"references remain valid.\");      using non_const_result_t = std::pair&lt;std::reference_wrapper&lt;value_t&gt;, size_t&gt;;      using const_result_t = std::pair&lt;std::reference_wrapper&lt;std::add_const_t&lt;value_t&gt;&gt;, size_t&gt;;      using result_t = std::optional&lt;std::variant&lt;non_const_result_t, const_result_t&gt;&gt;;                  result_t result{};      ([&amp;] {        if constexpr (std::is_same_v&lt;std::remove_cvref_t&lt;decltype(tuple_values)&gt;, value_t&gt;) {          if (!result &amp;&amp; idx &gt;= index &amp;&amp; std::equal_to{}(value, tuple_values)) {            if constexpr (std::is_const_v&lt;std::remove_reference_t&lt;decltype(tuple_values)&gt;&gt;) {              result = result_t{std::in_place, const_result_t{tuple_values, idx}};            } else {              result = result_t{std::in_place, non_const_result_t{tuple_values, idx}};            }          }        }      }() , ...);      return result;    }, std::forward&lt;tuple_t&gt;(tuple));  }(std::make_index_sequence&lt;std::tuple_size&lt;std::remove_cvref_t&lt;tuple_t&gt;&gt;{}&gt;{});}Example Use CasesNow that the tuple_find function is fully implemented and all important design decisions have been discussed, the following examples illustrate its practical use. The examples cover both typical runtime scenarios and constexpr use cases.1. Search and Modify Values (Runtime)This example shows how to find multiple occurrences of a value in a std::tuple and modify them afterward. The return value is a real reference - any changes affect the underlying variables directly:int a{20}, b{10}, c{10}, d{30};auto tpl = std::tie(a, b, c, d);size_t idx = 0;while (true) {  auto result = tuple_find(tpl, 10, idx);  if (!result) break;  auto&amp; ref = std::get&lt;0&gt;(*result); // Access non-const reference  std::cout &lt;&lt; \"Found: \" &lt;&lt; ref.first &lt;&lt; '\\n';  ref.first += 100; // Modify  idx = ref.second + 1; // Continue search from next index}std::cout &lt;&lt; \"New values: b = \" &lt;&lt; b &lt;&lt; \", c = \" &lt;&lt; c &lt;&lt; '\\n';Output:Found: 10  Found: 10  New values: b = 110, c = 1102. constexpr SupportSince tuple_find is fully constexpr - compatible, the search can also be executed at compile time. For example:static constexpr int x{10}, y{20}, z{30};constexpr auto tpl = std::tie(x, y, z);constexpr auto result = tuple_find(tpl, 10);if constexpr (result) {  static_assert(std::get&lt;1&gt;(*result).second == 0); // Match at position 0}This allows the function to be used inside static_assert or other consteval contexts.3. Reference Type Depends on Search MatchThe return type of tuple_find depends on the first matching element: If it is const, a const reference is returned—otherwise a modifiable one.int modifiable{10};const int immutable{10};auto tpl = std::tie(immutable, modifiable);auto result = tuple_find(tpl, 10);if (result) {  if (auto ptr = std::get_if&lt;0&gt;(&amp;*result)) {    std::cout &lt;&lt; \"non-const: \" &lt;&lt; ptr-&gt;first &lt;&lt; '\\n';  } else {    std::cout &lt;&lt; \"const: \" &lt;&lt; std::get&lt;1&gt;(*result).first &lt;&lt; '\\n';  }}Output:const: 10Conclusiontuple_find is specifically designed for heterogeneous containers like std::tuple and introduces several characteristics that arise from C++’s type system and reference semantics:  Only elements whose type exactly matches the search value are considered. A search for int will not find a double, even if an implicit conversion would be allowed.  The return type is a std::variant that contains either a const or non-const reference. To safely access the result, the user needs to check which alternative was returned using std::get_if or std::holds_alternative.  A more generic version based on concepts like std::equality_comparable_with or std::convertible_to is not possible, since the reference type must be fully defined before the iteration starts. This is a limitation of using fold expressions, which cannot be short-circuited.Despite these limitations, tuple_find offers clear advantages:  The algorithm is fully constexpr-compatible  It allows direct reference access to found elements  It supports multiple matches using a start indexTogether, these features provide a precise and modern solution for working with std::tuple, addressing common real-world problems without sacrificing clarity or performance.Share your feedbackPraise or criticism is appreciated!"
  },
  
  {
    "title": "Constexpr-Compatible Function for std::tuple - Part 1: tuple_for_each",
    "url": "/posts/implementing-constexpr-compatible-algorithms-for-heterogeneous-containers-tuple-for-each/",
    "categories": "Compile-time programming, Algorithms for Heterogeneous Containers",
    "tags": "c++, constexpr, compile-time, lambda, nttp, tuple, std-tuple, algorithms, heterogeneous-containers, tuple-for-each, std-apply, perfect-forwarding, fold-expressions, parameter-pack, variadic-template, forwarding-reference, comma-operator, if-constexpr, std-invoke, value-category, static_assert",
    "date": "2025-02-26 00:00:00 +0100",
    





    
    "snippet": "IntroductionHeterogeneous containers are an essential tool in modern C++ applications, especially when values of different types need to be managed and processed together. While the standard librar...",
    "content": "IntroductionHeterogeneous containers are an essential tool in modern C++ applications, especially when values of different types need to be managed and processed together. While the standard library provides numerous algorithms for homogeneous containers such as std::vector, similar functionality for heterogeneous containers like std::tuple is missing.This article series aims to close this gap - not by introducing a ready-made library, but by demonstrating how to develop such algorithms from scratch. The goal is to remove barriers that prevent many developers from writing their own algorithms for heterogeneous containers.The idea of treating std::tuple as a fully-fledged container and developing algorithms for it emerged during the implementation of a compile-time command-line parser, where std::tuple proved to be extremely useful.This article focuses on implementing one such algorithm: tuple_for_each. This function enables iteration over each element in an std::tuple and applies a given action to each element - similar to std::for_each for homogeneous containers.Beyond explaining a useful function, the article aims to provide a deeper understanding of the mechanisms involved. Once these principles are understood, developing custom algorithms for std::tuple or other heterogeneous containers - whether for iteration, search, or transformation - becomes significantly easier.tuple_for_each – Iteration Over Heterogeneous ContainersWe start with the simplest operation: iterating over an std::tuple. This first algorithm serves not only as a practical application but also introduces fundamental techniques necessary for developing further algorithms for heterogeneous containers.To illustrate how tuple_for_each works, consider the following simple example:std::tuple values{42, 3.14, \"Hello\"};tuple_for_each(values, [](auto const&amp; value) {  std::cout &lt;&lt; value &lt;&lt; '\\n';});Output:423.14HelloHere, tuple_for_each invokes the provided action on each element within the std::tuple, similar to std::for_each for homogeneous containers.  tuple_for_each is not limited to runtime execution; it is specifically designed to be used in compile-time programming as well.Passing the Tuple and Perfect ForwardingThe heterogeneous container is passed as a forwarding reference (tuple_t&amp;&amp;), allowing perfect forwarding to preserve the value category of both the std::tuple and its elements.template &lt;typename tuple_t, typename action_t&gt;constexpr auto tuple_for_each(tuple_t&amp;&amp; tuple, action_t action) noexcept {  ...}If the original std::tuple was modifiable, it remains so within the action. Conversely, if the original std::tuple was immutable, that restriction is also enforced within the action.This flexibility ensures that the function supports a wide range of use cases without introducing unnecessary constraints.The action is passed by value since it is typically a stateless lambda or functor, which requires only 1 byte of storage. Passing it by reference would generally be less efficient, consuming at least 4 or 8 bytes.Iterating Over Tuple Elements with std::apply and Fold ExpressionsHeterogeneous containers like std::tuple do not support classical iteration with loops or iterators, unlike homogeneous containers such as std::vector. To iterate over all tuple values, they must be made available as a parameter pack.To achieve this, the processing code is encapsulated in a lambda function, which is then forwarded along with the std::tuple to std::apply:std::apply([](auto&amp;&amp;... tuple_values) {  // Access to all elements in the tuple}, std::forward&lt;tuple_t&gt;(tuple));std::apply extracts the elements from the std::tuple and passes them as arguments to the lambda function. The variadic template with forwarding references (auto&amp;&amp;... tuple_values) ensures that the elements are available as a parameter pack for subsequent iteration.The actual iteration over the elements is performed using a fold expression with the comma operator:(call_action(std::forward&lt;decltype(tuple_values)&gt;(tuple_values)), ...);This fold expression invokes call_action for each element in the parameter pack.auto call_action = [&amp;](auto&amp;&amp; tuple_value) {  if constexpr (std::invocable&lt;action_t, decltype(tuple_value)&gt;) {    std::invoke(action, std::forward&lt;decltype(tuple_value)&gt;(tuple_value));  }};The if constexpr condition checks whether the action can be invoked with the current element (std::invocable). If the condition is met, std::invoke is used to execute the action on the tuple element.Perfect forwarding (std::forward) ensures that the original value category of the element is maintained, avoiding unnecessary copies and preserving references.Why if constexpr?A normal if statement would not work in this case because it is a runtime construct. This means the compiler would instantiate all possible code paths regardless of the condition. If even a single tuple element is incompatible with the action, the std::invoke call would fail, resulting in a compilation error.if constexpr, on the other hand, is a compile-time construct. The compiler eliminates code paths where the condition evaluates to false, ensuring that only valid elements are passed to the action.Strict Mode – Ensuring Compatibility with All ElementsBy default, tuple_for_each is designed to skip elements that are not compatible with the provided action. If the action cannot be invoked with a specific element type, that element is simply ignored.However, in some cases, it may be required that the action be compatible with every element in the tuple. This is where the strict mode comes into play.Strict mode is enabled using a boolean non-type template parameter (NTTP):template &lt;bool strict = false, typename tuple_t, typename action_t&gt;constexpr auto tuple_for_each(tuple_t&amp;&amp; tuple, action_t action) noexcept {  std::apply([&amp;](auto&amp;&amp;... tuple_values) {    static_assert(!strict || ((std::invocable&lt;action_t, decltype(tuple_values)&gt;) &amp;&amp; ...),      \"Error: In strict mode, the action must be callable with every element in the tuple.\");    auto call_action = [&amp;](auto&amp;&amp; tuple_value) {      if constexpr (std::invocable&lt;action_t, decltype(tuple_value)&gt;) {        std::invoke(action, std::forward&lt;decltype(tuple_value)&gt;(tuple_value));      }     };    (call_action(std::forward&lt;decltype(tuple_values)&gt;(tuple_values)), ...);      }, std::forward&lt;tuple_t&gt;(tuple));}How It Works  strict = false (default behavior): If an element is not compatible with the action, it is simply skipped.  strict = true: The action must be callable with every element in the tuple. If this requirement is not met, static_assert produces a compile-time error.Why Is Strict Mode an NTTP?Strict mode must be configured at compile time since it is evaluated inside static_assert. Therefore, it must be defined as a non-type template parameter (NTTP) rather than a function argument.Example: Enforcing Strict Modestd::tuple values{42, 3.14, \"Hello\"};tuple_for_each&lt;true&gt;(values, [](int value) {  std::cout &lt;&lt; value &lt;&lt; '\\n';});Since \"Hello\" (char const[6]) is incompatible with int, compilation fails.ConclusionWith tuple_for_each, we have developed an algorithm that enables iteration over elements in an std::tuple and applies an action to them. Key features include:  Support for both modifiable and constant elements through perfect forwarding.  Automatic skipping of incompatible elements, with an optional strict mode to enforce compatibility.  constexpr compatibility, allowing usage at both compile-time and runtime.Next: The next article explores tuple_find, a constexpr-capable function for searching values in std::tuple, which presents additional challenges and solutions.Share your feedbackPraise or criticism is appreciated!"
  },
  
  {
    "title": "NTTP Builder Strategy – constexpr Conversion of 'vector to array'",
    "url": "/posts/nttp-compile-time-builder-strategy-constexpr-conversion-of-vector-to-array/",
    "categories": "C++, Compile-time programming",
    "tags": "c++, c++20, constexpr, compile-time, builder, array, vector, literal-type, lambda, conversion, staging, strategy, nttp, constant-expression",
    "date": "2025-02-21 00:00:00 +0100",
    





    
    "snippet": "IntroductionNon-Type Template Parameters (NTTPs) are a powerful feature of compile-time programming in C++. They allow values to be passed and processed at compile time. However, they come with a s...",
    "content": "IntroductionNon-Type Template Parameters (NTTPs) are a powerful feature of compile-time programming in C++. They allow values to be passed and processed at compile time. However, they come with a significant limitation: only literal types1 are allowed.This means that many commonly used standard types, such as std::string or std::vector, cannot be passed as NTTPs. In many use cases, it would be beneficial to utilize dynamic or complex data types in a similar manner.The NTTP Compile-Time Builder Strategy provides a way to achieve exactly that.This article explains how this technique works and in which scenarios it can be effectively used.Core Concept: The NTTP Compile-Time Builder StrategyThe NTTP Compile-Time Builder Strategy consists of the following steps:1. Encapsulation of Value Creation in a BuilderInstead of passing the value directly, we define a constexpr lambda function that generates and returns the desired value. This lambda acts as a builder, describing how the value is created without instantiating it immediately.constexpr auto str_builder = [] { return std::string{\"Hello NTTP!\"}; };2. Passing the Builder as an NTTPSince lambdas in C++ are implicitly constexpr, they can be passed as NTTPs. This allows non-literal types to be processed at compile time indirectly.constexpr auto str_builder = [] { return std::string{\"Hello NTTP!\"}; };auto main() -&gt; int {  process_string&lt;str_builder&gt;(); // Passing the Builder as an NTTP}3. Generating the Value within the FunctionInside the target function (process_string), the builder is executed to generate the desired value at compile time.template &lt;auto builder&gt;auto process_string() {  std::string str = builder(); // Generate the value using the builder  // Further processing...}After explaining the fundamentals of the NTTP Compile-Time Builder Strategy, let’s look at a concrete use case.Practical Example: Converting std::vector&lt;int&gt; to std::array&lt;int, N&gt;Implementation:template &lt;size_t max_size, auto builder&gt;constexpr auto to_array() noexcept {  namespace rng = std::ranges;  constexpr auto data = [] {    auto const int_vec = builder();    std::array&lt;int, max_size&gt; result{};    auto const end_pos = rng::copy(int_vec, rng::begin(result)).out;    auto const right_size = rng::distance(rng::begin(result), end_pos);    return std::pair{result, right_size};  }();  std::array&lt;int, data.second&gt; result{};  rng::copy_n(rng::begin(data.first), data.second, rng::begin(result));  return result;}How Does the Conversion Work?The to_array function applies the NTTP Compile-Time Builder Strategy to transform a std::vector&lt;int&gt; into a std::array&lt;int, N&gt; at compile time.The first NTTP defines the size of the array. This size is not automatically derived but must be explicitly passed at the function call. It must be large enough to hold the entire contents of the std::vector. The size cannot be inferred from std::vector because std::array requires a constant expression for its size.The second NTTP is the builder, which describes how the std::vector is created.Inside to_array, the builder executes to generate a std::vector at compile time.The contents of the vector are copied into an oversized array (std::array&lt;int, max_size&gt;), and the exact number of copied elements is determined.These values — the temporary array and its corresponding element count — are returned in a std::pair.Why This Intermediate Step?The key limitation of std::array is that its size must be known at compile time. We can only create the final array once its exact size is available as a constant expression. To achieve this, the entire process is wrapped in a lambda function, a technique known as Compile-Time Staging Strategy (CTSS).  For more details on CTSS:  Compile-Time Staging Strategy (CTSS): constexpr Conversion of int to std::string_viewIn the final step, the temporary oversized array is trimmed to its actual size and returned as a constexpr value.Usage Example:constexpr auto vector_builder = [] {  std::vector&lt;int&gt; vec{0, 8, 15};  vec.push_back(50);  // Familiar handling of std::vector  return vec;};static constexpr auto arr = to_array&lt;42, vector_builder&gt;();Now, the builder’s result is available as a constexpr value and can be further processed.When is such a conversion useful?Since C++20, many types that were previously restricted to runtime, including std::vector, can now be used in constexpr contexts — even though they involve dynamic memory management. This makes it possible to work with std::vector at compile-time just as flexibly as at runtime.The advantages are clear:  Dynamic memory management → Elements can be added or removed dynamically.  Flexibility → The number of elements does not need to be known in advance.However, there is a critical limitation:Dynamically allocated memory must also be deallocated at compile-time. This means that std::vector cannot retain its values beyond compile-time, as its allocated memory is freed once the constexpr execution is complete.To store values permanently in a compile-time data structure, we need to convert std::vector into an std::array.When Is the NTTP Compile-Time Builder Strategy Necessary?The NTTP Compile-Time Builder Strategy is a powerful tool, but it is not always required. In some cases, a std::vector can simply be passed as a regular function argument without needing a builder.However, in this specific example, passing a std::vector as a function argument would not be possible because the lambda inside to_array would need to capture it by reference. Since function parameters are never constexpr, capturing a reference to the std::vector would create a non-constexpr reference, which is not allowed inside a constexpr function.This approach is particularly beneficial when combined with the Compile-Time Staging Strategy (CTSS). Whenever the generated value needs to be used in a context that initializes a constexpr variable, the NTTP Compile-Time Builder Strategy fully demonstrates its advantages.ConclusionThis article has demonstrated how the NTTP Compile-Time Builder Strategy enables the use of non-literal types as NTTPs, allowing dynamic structures like std::vector to be utilized in pure compile-time processing.In combination with Compile-Time Staging Strategy (CTSS), this technique provides a flexible and efficient way to manage complex data transformations at compile time, ensuring that dynamically generated values remain valid beyond their immediate execution scope.Share your feedbackPraise or criticism is appreciated!Footnote            What are Literal Types?      A literal type in C++ is a type that can be used in a constexpr context, meaning inside constant expressions. This includes:              Built-in types such as int, char, double, bool, and nullptr_t        Enumerations (enum and enum class)        Pointer types to literal types, including const and nullptr_t pointers        Pointers to members of literal types        Literal classes2            &#8617;&#xfe0e;              Requirements for a class to be a literal class              All non-static members must be literals.        The class must have at least one user-defined constexpr constructor, or all non-static members must be initialized in-class.        In-class initializations for non-static members of built-in types must be constant expressions.        In-class initializations for non-static members of class types must either use a user-defined constexpr constructor or have no     initializer. If no initializer is given, the default constructor of the class must be constexpr. Alternatively, all non-static members of the class must be initialized in-class.        A constexpr constructor must initialize every member or at least those that are not initialized in-class.        Virtual or normal default destructors are allowed, but user-defined destructors with {} are not allowed. User-defined     constructors with {} are allowed if they are declared as constexpr. However, user-defined constexpr destructors in literal classes are often of limited use because literal classes do not manage dynamic resources. In non-literal classes, however, they can be important, especially for properly deallocating dynamic resources in a constexpr context.        Virtual functions are allowed, but pure virtual functions are not.        Private and protected member functions are allowed.        Private and protected inheritance are allowed, but virtual inheritance is not.        Aggregate classes3 with only literal non-static members are also considered literal classes. This applies to all aggregate classes without a base class or if the base class is a literal class.        Static member variables and functions are allowed if they are constexpr and of a literal type.        Friend functions are allowed inside literal classes.        Default arguments for constructors or functions must be constant expressions.                    A literal type ensures that objects of this type can be evaluated at compile time, as long as all dependent expressions are constexpr.            &#8617;&#xfe0e;              Requirements for a class to be a aggregate class              What is allowed:                      Public members            User-declared destructor            User-declared copy and move assignment operators            Members can be not literals            Public inheritance            Protected or private static members                          What is not allowed:                      Protected and private non-static members            User-declared constructors            Virtual destructor            Virtual member functions            Protected/private or virtual inheritance            Inherited constructors (by using declaration)                          Restrictions for the base class:                      Only public non-static members allowed OR            Public constructor required for non-public non-static members                              &#8617;&#xfe0e;      "
  },
  
  {
    "title": "Staging Strategy (CTSS): constexpr Conversion of 'int to string_view'",
    "url": "/posts/compile-time-staging-strategy-ctss-constexpr-conversion-of-int-to-string-view/",
    "categories": "C++, Compile-time programming",
    "tags": "c++, c++20, c++23, constexpr, consteval, compile-time, int, string-view, array, literal-type, lambda, conversion, staging, strategy, nttp, ctss, constant-expression",
    "date": "2025-02-04 00:00:00 +0100",
    





    
    "snippet": "IntroductionWith the latest constexpr extensions in C++, we can perform more and more computations at compile time. However, in practice, we repeatedly encounter a specific problem: What do we do w...",
    "content": "IntroductionWith the latest constexpr extensions in C++, we can perform more and more computations at compile time. However, in practice, we repeatedly encounter a specific problem: What do we do when a non-constexpr variable suddenly needs to be constexpr later in the program?A typical example: The size member of a std::string is used to instantiate a std::array of the corresponding size. The compiler rejects this because the size is not a constant expression.This is where the Compile-Time Staging Strategy (CTSS) comes into play. It allows us to make values constexpr in multiple stages.In this article, we will take a detailed look at how CTSS works, using the example of converting an int to a std::string_view at compile time.How Non-constexpr Values Can Become a RoadblockWhen converting an integer value to a string representation, we face a problem: The number of required characters depends on the value itself. It is impossible to predict the number of digits in advance when the number is the result of a complex computation. Therefore, we need to create an oversized array and trim it to the exact required size.namespace rng = std::ranges;constexpr auto calculation(int init) { return (init % 17) * 42 + 5; }template &lt;auto buffer_size, auto int_builder&gt;consteval auto int_to_string_view() {  std::array&lt;char, buffer_size&gt; oversized_buffer{};  auto const result = std::to_chars(rng::begin(oversized_buffer),                                    rng::end(oversized_buffer),                                    int_builder());  auto const right_size = rng::distance(rng::cbegin(oversized_buffer),                                        result.ptr);  std::array&lt;char, right_size + 1&gt; rightsize_buffer{}; // Error  ...}constexpr auto str_view = int_to_string_view&lt;32, [] {  return calculation(42);}&gt;();  However, this step fails because the determined size (in our case, the variable right_size) is not a constant expression.The Compile-Time Staging Strategy (CTSS) provides an elegant solution to this problem. It allows us to transform intermediate results   into constexpr values in multiple stages, ultimately enabling the creation of a valid std::string_view.The Compile-Time Staging Strategy (CTSS)The first step is done: We have identified the problem. In our example, the rightsize_buffer array expects right_size to be a constant expression – but it isn’t.To resolve this issue, we encapsulate the entire code up to the error inside a constexpr lambda and return all values that need to be constexpr. In our case, this is right_size. Additionally, we need to return the oversized array oversized_buffer so we can later trim it to the exact required size.namespace rng = std::ranges;template &lt;auto buffer_size, auto int_builder&gt;consteval auto int_to_string_view() {  constexpr auto intermediate_result = [] {     std::array&lt;char, buffer_size&gt; oversized_buffer{};    auto const result = std::to_chars(rng::begin(oversized_buffer),                                      rng::end(oversized_buffer),                                      int_builder());    auto const right_size = rng::distance(rng::cbegin(oversized_buffer),                                          result.ptr);    return std::pair{oversized_buffer, right_size};  }();  ...}Important Considerations:      All return values must be of literal types1, as only these can be used to initialize constexpr variables (such as intermediate_result).        The lambda must not capture any non-constexpr values from its surrounding scope, as that would make it non-evaluatable at compile time. Although this is not an issue in our example, it is a common source of errors in compile-time programming and should always be kept in mind.  With this, the first staging step is complete: We now have the relevant values in a constexpr-compatible form and can proceed to the next step — adjusting the array size.Adjusting the Array SizeCreating an array with the exact required size is no longer an issue since we now have the precise size available as a constexpr value. We reserve an extra byte for the ‘null terminator’ and copy all characters from the oversized array into the appropriately sized rightsize_buffer array.namespace rng = std::ranges;template &lt;auto value&gt; consteval auto&amp; to_static() { return value; }template &lt;auto buffer_size, auto int_builder&gt;consteval auto int_to_string_view() {  constexpr auto intermediate_result = [] {     std::array&lt;char, buffer_size&gt; oversized_buffer{};    auto const result = std::to_chars(rng::begin(oversized_buffer),                                      rng::end(oversized_buffer),                                      int_builder());    auto const right_size = rng::distance(rng::cbegin(oversized_buffer),                                          result.ptr);    return std::pair{oversized_buffer, right_size};  }();  std::array&lt;char, intermediate_result.second + 1&gt; rightsize_buffer{};  rng::copy_n(rng::cbegin(intermediate_result.first),                          intermediate_result.second,                          rng::begin(rightsize_buffer));  rightsize_buffer[intermediate_result.second] = '\\0';  return std::string_view{to_static&lt;rightsize_buffer&gt;()}; // Error}  At this point, we face another problem: How do we return a std::string_view pointing to an array when that array is a local variable? Simply declaring the variable as static is not allowed in a constexpr context.Two Possible Solutions:      Declare the rightsize_buffer array as static constexpr2.        Declare rightsize_buffer as constexpr and make the array indirectly static by passing it to the helper function to_static. By passing the constexpr array as a Non-Type Template Parameter (NTTP), the array is placed in static storage, and to_static simply returns a reference to this memory.  In both cases, the rightsize_buffer array must be declared as constexpr. However, directly declaring it as constexpr is not possible, as the subsequent copy operation would otherwise fail.Once again, we face the challenge of a non-constexpr variable that needs to become constexpr later in the program.Final StagingAt this point, we apply the Compile-Time Staging Strategy one last time. After identifying the error, we again encapsulate the relevant code in a constexpr lambda and return all values that need to be constexpr. In this case, it is only the rightsize_buffer array itself.Finally, we pass the array as an NTTP to our helper function to_static. The returned reference to the statically stored array is then used to create and return a std::string_view instance.namespace rng = std::ranges;template &lt;auto value&gt; consteval auto&amp; to_static() { return value; }template &lt;auto buffer_size, auto int_builder&gt;consteval auto int_to_string_view() {  constexpr auto intermediate_result = [] {     std::array&lt;char, buffer_size&gt; oversized_buffer{};    auto const result = std::to_chars(rng::begin(oversized_buffer),                                      rng::end(oversized_buffer),                                      int_builder());    auto const right_size = rng::distance(rng::cbegin(oversized_buffer),                                          result.ptr);    return std::pair{oversized_buffer, right_size};  }();  constexpr auto rightsize_buffer = [&amp;intermediate_result] {    std::array&lt;char, intermediate_result.second + 1&gt; rightsize_buffer{};    rng::copy_n(rng::cbegin(intermediate_result.first),                intermediate_result.second,                rng::begin(rightsize_buffer));    rightsize_buffer[intermediate_result.second] = '\\0';    return rightsize_buffer;  }();  return std::string_view{to_static&lt;rightsize_buffer&gt;()};}auto main() -&gt; int {  constexpr auto str_view = int_to_string_view&lt;32, [] {    return calculation(42);  }&gt;();  ...}Unlike the first staging step, this time we capture an external variable inside the lambda. However, this is completely safe because it only captures the constexpr variable intermediate_result. This ensures that the lambda remains constexpr-evaluatable, avoiding the previously mentioned pitfall.With this last step, the conversion is complete. We have successfully transformed an int into a constexpr-evaluatable std::string_view while ensuring that all required values are truly constexpr.Summary of the Compile-Time Staging Strategy (CTSS)      Identify the error – Analyze which variable is not constexpr but needs to be.        Encapsulate code – Extract the affected code into a constexpr lambda that returns the necessary values.        Watch for pitfalls – Ensure that no non-constexpr values are captured and that only literal types are returned.        Store values in constexpr variables – Use the returned values to initialize constexpr variables.        Final processing – Use the now constexpr-compatible values for the actual computation, such as creating a std::string_view.  ConclusionThe Compile-Time Staging Strategy is a useful technique for many scenarios where constexpr constraints in C++ seem to pose a challenge. It allows us to solve complex problems and unlocks new possibilities for optimized, efficient programs. With the continuous improvements in C++20 and C++23, compile-time programming is becoming increasingly powerful—and strategies like CTSS help us make the most of it.Share your feedbackPraise or criticism is appreciated!Footnote            What are Literal Types?      A literal type in C++ is a type that can be used in a constexpr context, meaning inside constant expressions. This includes:              Built-in types such as int, char, double, bool, and nullptr_t        Enumerations (enum and enum class)        Pointer types to literal types, including const and nullptr_t pointers        Pointers to members of literal types        Literal classes3            &#8617;&#xfe0e;              Since C++23, it is allowed to declare variables as static constexpr in a constexpr context. However, we do not use this approach because the Clang compiler currently has issues handling static constexpr inside consteval functions. &#8617;&#xfe0e;              Requirements for a class to be a literal class              All non-static members must be literals.        The class must have at least one user-defined constexpr constructor, or all non-static members must be initialized in-class.        In-class initializations for non-static members of built-in types must be constant expressions.        In-class initializations for non-static members of class types must either use a user-defined constexpr constructor or have no     initializer. If no initializer is given, the default constructor of the class must be constexpr. Alternatively, all non-static members of the class must be initialized in-class.        A constexpr constructor must initialize every member or at least those that are not initialized in-class.        Virtual or normal default destructors are allowed, but user-defined destructors with {} are not allowed. User-defined     constructors with {} are allowed if they are declared as constexpr. However, user-defined constexpr destructors in literal classes are often of limited use because literal classes do not manage dynamic resources. In non-literal classes, however, they can be important, especially for properly deallocating dynamic resources in a constexpr context.        Virtual functions are allowed, but pure virtual functions are not.        Private and protected member functions are allowed.        Private and protected inheritance are allowed, but virtual inheritance is not.        Aggregate classes4 with only literal non-static members are also considered literal classes. This applies to all aggregate classes without a base class or if the base class is a literal class.        Static member variables and functions are allowed if they are constexpr and of a literal type.        Friend functions are allowed inside literal classes.        Default arguments for constructors or functions must be constant expressions.                    A literal type ensures that objects of this type can be evaluated at compile time, as long as all dependent expressions are constexpr.            &#8617;&#xfe0e;              Requirements for a class to be a aggregate class              What is allowed:                      Public members            User-declared destructor            User-declared copy and move assignment operators            Members can be not literals            Public inheritance            Protected or private static members                          What is not allowed:                      Protected and private non-static members            User-declared constructors            Virtual destructor            Virtual member functions            Protected/private or virtual inheritance            Inherited constructors (by using declaration)                          Restrictions for the base class:                      Only public non-static members allowed OR            Public constructor required for non-public non-static members                              &#8617;&#xfe0e;      "
  },
  
  {
    "title": "Compile-Time Programming: New Possibilities with C++20 and C++23",
    "url": "/posts/compile-time-programming-new-possibilities-with-cpp20-and-cpp23/",
    "categories": "C++, Compile-time programming",
    "tags": "c++, c++20, c++23, constexpr, consteval, compile-time, prvalue, lambda, string, string-view, array, literal-type, performance, optimization, conversion",
    "date": "2025-01-31 12:00:00 +0100",
    





    
    "snippet": "IntroductionEfficiency is a key factor in modern C++ projects. Especially in performance-critical applications, it is beneficial to avoid expensive memory allocations and runtime computations. The ...",
    "content": "IntroductionEfficiency is a key factor in modern C++ projects. Especially in performance-critical applications, it is beneficial to avoid expensive memory allocations and runtime computations. The new features in C++20 and C++23 greatly expand compile-time programming, allowing even non-literal types like std::string and std::vector to be processed at compile time.In this article, I will show a concrete example of how to efficiently convert std::string into std::string_view at compile time. This reduces runtime costs, avoids unnecessary dynamic memory allocations, and enables new optimizations – such as for logging or generated code metadata. In addition to the new language features, I will explain fundamental concepts of compile-time programming and present practical solutions to common challenges.Challenge: Using std::string as constexprEvery call to a constexpr or consteval function from a non-constexpr context requires all function arguments to be literal types1, meaning their values must be known at compile time.However, std::string is not a literal type, even though it has constexpr constructors since C++20 and can be used in a constexpr context at compile time.Let’s consider the following example:auto main() -&gt; int { // non-constexpr context  std::string str{\"hello world\"};   constexpr auto str_view = to_string_view(str);  return 0;}Here, the call fails because std::string cannot be used as an argument in a constexpr function to initialize a constexpr variable.It also does not help to declare the variable str as constexpr, as shown in the following example:auto main() -&gt; int { // non-constexpr context  constexpr std::string str{\"hello world\"};  constexpr auto str_view = to_string_view(str);  return 0;}1. Passing a prvalue instead of an lvalueInstead of passing a variable, we use a temporary value (prvalue):auto main() -&gt; int { // non-constexpr context  constexpr auto str_view = to_string_view(std::string{\"hello world\"});  return 0;}Since C++17, prvalues are no longer objects but pure expressions. The materialization into an object occurs only within the constexpr function to_string_view, making the code valid because the temporary std::string does not need to be constexpr at the time of the call.2. Using a Lambda FunctionAlternatively, the std::string can be encapsulated in a lambda:auto main() -&gt; int { // non-constexpr context  constexpr auto str_view = [] {    std::string str{\"hello world\"};    return to_string_view(str);  }();  return 0;}Since lambdas have been implicitly constexpr since C++17, the call to the constexpr function takes place from a constexpr context.Converting std::string into std::arrayTo implement to_string_view, we first convert std::string into std::array.namespace rng = std::ranges;template &lt;auto max_size&gt; consteval auto to_string_view(std::string const&amp; str) {  std::array&lt;char, max_size&gt; max_size_array{};  rng::copy(str, max_size_array.begin());  return max_size_array;}auto main() -&gt; int { // non-constexpr context  constexpr auto str_view = to_string_view&lt;128&gt;(std::string{\"hello world!\"});  return 0;}  The key limitation of std::string and other non-literal types is that they must deallocate their memory in a constexpr context. If their values need to leave the constexpr context, they must be copied into a literal type1.std::array is therefore an ideal choice for storing the std::string value. The maximum size of the array is passed as a Non-Type Template Parameter (NTTP) because function parameters in C++ can never be constexpr and when instantiating the right_size_array array, max_size must be a constant expression.Dynamic Adjustment of Array SizeSince we never know the exact array size in advance, we first create an oversized array and then trim it to the exact size.namespace rng = std::ranges;template &lt;auto max_size&gt; constexpr auto to_oversized_array(std::string const&amp; str) {  std::array&lt;char, max_size&gt; max_size_array{};  auto const end_pos = rng::copy(str, rng::begin(max_size_array));  auto const right_size = rng::distance(rng::cbegin(max_size_array), end_pos.out);  return std::pair{max_size_array, right_size};}template &lt;auto max_size&gt; consteval auto to_string_view(std::string const&amp; str) {  constexpr auto intermediate_data = to_oversized_array&lt;max_size&gt;(str);  std::array&lt;char, intermediate_data.second&gt; right_size_array{};  rng::copy_n(rng::cbegin(intermediate_data.first), intermediate_data.second,              rng::begin(right_size_array));  return right_size_array;}Problem: Function Parameters in C++ Are Never constexprThe function parameter str is not constexpr, yet we pass it as an argument to a constexpr function that initializes a constexpr variable. However, the variable intermediate_data must remain constexpr because, when instantiating the right_size_array array (line 14), the size must be a constant expression.Solution: Lambda as NTTPInstead of passing std::string as a parameter, we encapsulate it in a lambda and pass it as an NTTP.namespace rng = std::ranges;template &lt;auto max_size, auto string_builder&gt; constexpr auto to_oversized_array() {  std::array&lt;char, max_size&gt; max_size_array{};  auto const end_pos = rng::copy(string_builder(), rng::begin(max_size_array));  auto const right_size = rng::distance(rng::cbegin(max_size_array), end_pos.out);  return std::pair{max_size_array, right_size};}template &lt;auto max_size, auto string_builder&gt; consteval auto to_string_view() {  constexpr auto intermediate_data = to_oversized_array&lt;max_size, string_builder&gt;();  std::array&lt;char, intermediate_data.second&gt; right_size_array{};  rng::copy_n(rng::cbegin(intermediate_data.first), intermediate_data.second,              rng::begin(right_size_array));  return right_size_array;}auto main() -&gt; int { // non-constexpr context  constexpr auto str_view = to_string_view&lt;128, [] {    return std::string{\"hello world!\"}; }&gt;();  return 0;}Optimization: OptionalTo keep everything in place, we encapsulate the function to_oversized_array in a lambda.namespace rng = std::ranges;template &lt;auto max_size, auto string_builder&gt; consteval auto to_string_view() {  constexpr auto intermediate_data = [] {    std::array&lt;char, max_size&gt; max_size_array{};    auto const end_pos = rng::copy(string_builder(), rng::begin(max_size_array));    auto const right_size = rng::distance(rng::cbegin(max_size_array), end_pos.out);    return std::pair{max_size_array, right_size};  }();  std::array&lt;char, intermediate_data.second&gt; right_size_array{};  rng::copy_n(rng::cbegin(intermediate_data.first), intermediate_data.second,  rng::begin(right_size_array));  return right_size_array;}Converting std::array into std::string_viewBy marking the array right_size_array with static constexpr, we store it in static memory and allow it to be referenced using a std::string_view instance. This instance is then returned to the caller of the to_string_view function.namespace rng = std::ranges;template &lt;auto max_size, auto string_builder&gt; consteval auto to_string_view() {  constexpr auto intermediate_data = [] {    std::array&lt;char, max_size&gt; max_size_array{};    auto const end_pos = rng::copy(string_builder(), rng::begin(max_size_array));    auto const right_size = rng::distance(rng::cbegin(max_size_array), end_pos.out);    return std::pair{max_size_array, right_size};  }();  static constexpr auto right_size_array = [&amp;intermediate_data] {    std::array&lt;char, intermediate_data.second&gt; right_size_array{};    rng::copy_n(rng::cbegin(intermediate_data.first), intermediate_data.second,                rng::begin(right_size_array));    return right_size_array;  }();  return std::string_view{right_size_array}; }Portability: Using to_static for ClangSince Clang has issues with static constexpr in consteval functions in C++23, the following helper function ensures portability:template &lt;auto value&gt; consteval auto&amp; to_static() { return value; }We call this function with the array right_size_array as a Non-Type Template Parameter (NTTP). NTTPs allow values to be stored directly in the static memory area, making them referenceable. This way, we can safely store std::array data in static memory and return it as std::string_view.namespace rng = std::ranges;template &lt;auto value&gt; consteval auto&amp; to_static() { return value; }template &lt;auto max_size, auto string_builder&gt;consteval auto to_string_view() {  constexpr auto intermediate_data = [] {    std::array&lt;char, max_size&gt; max_size_array{};    auto const end_pos = rng::copy(string_builder(), rng::begin(max_size_array));    auto const right_size = rng::distance(rng::cbegin(max_size_array), end_pos.out);    return std::pair{max_size_array, right_size};  }();  constexpr auto right_size_array = [&amp;intermediate_data] {    std::array&lt;char, intermediate_data.second&gt; right_size_array{};    rng::copy_n(rng::cbegin(intermediate_data.first), intermediate_data.second,                            rng::begin(right_size_array));    return right_size_array;   }();  return std::string_view{to_static&lt;right_size_array&gt;()};}With this, our compile-time conversion from std::string to std::string_view is not only complete but also portable and efficient.Use Case: Compile-Time Generation of Log TagsA practical example is creating log tags for generic types:template &lt;typename T&gt;constexpr auto type_name() { // GCC only  constexpr std::string_view prefix = \"constexpr auto type_name() [with T = \";  std::string_view name = __PRETTY_FUNCTION__;  name.remove_prefix(prefix.size());  name.remove_suffix(1);  return name;}template &lt;typename T&gt;constexpr auto log_tag() {  return to_string_view&lt;64, [] { return \"Log&lt;\" + std::string(type_name&lt;T&gt;()) + \"&gt;\"; }&gt;();}auto main() -&gt; int { // non-constexpr context  static constexpr auto log_string = log_tag&lt;std::vector&lt;std::string&gt;&gt;();  // output: Log&lt;std::vector&lt;std::__cxx11::basic_string&lt;char&gt; &gt;&gt;  return 0;}Here, a log tag for a generic type is created at compile time. This reduces runtime costs and avoids unnecessary memory allocations.ConclusionThe new features in C++20/23 enable powerful compile-time manipulations even for non-literal types. The techniques shown allow efficient conversion of std::string into std::string_view, reducing runtime costs.Especially in performance-critical applications, compile-time programming can provide significant advantages. The ability to process strings efficiently at compile time opens up exciting optimization possibilities – not only for logging but also for many other areas of modern C++ development.Share your feedbackPraise or criticism is appreciated!Footnote            What are Literal Types?      A literal type in C++ is a type that can be used in a constexpr context, meaning inside constant expressions. This includes:              Built-in types such as int, char, double, bool, and nullptr_t        Enumerations (enum and enum class)        Pointer types to literal types, including const and nullptr_t pointers        Pointers to members of literal types        Literal classes2            &#8617;&#xfe0e; &#8617;&#xfe0e;2              Requirements for a class to be a literal class              All non-static members must be literals.        The class must have at least one user-defined constexpr constructor, or all non-static members must be initialized in-class.        In-class initializations for non-static members of built-in types must be constant expressions.        In-class initializations for non-static members of class types must either use a user-defined constexpr constructor or have no     initializer. If no initializer is given, the default constructor of the class must be constexpr. Alternatively, all non-static members of the class must be initialized in-class.        A constexpr constructor must initialize every member or at least those that are not initialized in-class.        Virtual or normal default destructors are allowed, but user-defined destructors with {} are not allowed. User-defined     constructors with {} are allowed if they are declared as constexpr. However, user-defined constexpr destructors in literal classes are often of limited use because literal classes do not manage dynamic resources. In non-literal classes, however, they can be important, especially for properly deallocating dynamic resources in a constexpr context.        Virtual functions are allowed, but pure virtual functions are not.        Private and protected member functions are allowed.        Private and protected inheritance are allowed, but virtual inheritance is not.        Aggregate classes3 with only literal non-static members are also considered literal classes. This applies to all aggregate classes without a base class or if the base class is a literal class.        Static member variables and functions are allowed if they are constexpr and of a literal type.        Friend functions are allowed inside literal classes.        Default arguments for constructors or functions must be constant expressions.                    A literal type ensures that objects of this type can be evaluated at compile time, as long as all dependent expressions are constexpr.            &#8617;&#xfe0e;              Requirements for a class to be a aggregate class              What is allowed:                      Public members            User-declared destructor            User-declared copy and move assignment operators            Members can be not literals            Public inheritance            Protected or private static members                          What is not allowed:                      Protected and private non-static members            User-declared constructors            Virtual destructor            Virtual member functions            Protected/private or virtual inheritance            Inherited constructors (by using declaration)                          Restrictions for the base class:                      Only public non-static members allowed OR            Public constructor required for non-public non-static members                              &#8617;&#xfe0e;      "
  },
  
  {
    "title": "Understanding the 'Static Initialization Order Fiasco' in C++",
    "url": "/posts/understanding-the-static-initialization-order-fiasco-in-cpp/",
    "categories": "C++, Compile-time programming",
    "tags": "c++, static-initialization, initialization-order, constexpr, constinit, global-variables, static-variables, compile-time, linker, zero-initialization",
    "date": "2025-01-27 12:00:00 +0100",
    





    
    "snippet": "IntroductionThe Static Initialization Order Fiasco is a critical issue in C++ programming that can lead to unpredictable behavior in global and static variables. For C++ developers, understanding t...",
    "content": "IntroductionThe Static Initialization Order Fiasco is a critical issue in C++ programming that can lead to unpredictable behavior in global and static variables. For C++ developers, understanding this phenomenon is essential. This post explores the problem, illustrates it with examples, and provides solutions.The ProblemGlobal and static variables in C++ are usually initialized at compile time if their values can be determined at that time. However, if the initialization depends on a function that is not constexpr, even if the function’s arguments are known, compile-time initialization is not possible. In such cases, the variable is set to 0 (zero-initialized1).Let’s look at an example to understand this issue better.file1.cppauto sum(int a, int b) {  return a + b;}int sum_result = sum(5, 5);The global variable sum_result is set to 0 (zero-initialized) because the sum function is not marked as constexpr. Even though the values 5 and 5 are known at compile time, the lack of constexpr prevents the compiler from evaluating the result at compile time. Moreover, even with constexpr, initialization is not guaranteed unless stricter requirements like consteval are used — this will be discussed later.file2.cppextern int sum_result;int static_val = sum_result;The global variable static_val is also set to 0 (zero-initialized), as the value of sum_result is defined in another translation unit and not available in the current one.main.cppextern int sum_result;extern int static_val;auto main() -&gt; int {  std::cout &lt;&lt; \"sum_result = \" &lt;&lt; sum_result &lt;&lt; '\\n'; // output: 10  std::cout &lt;&lt; \"static_val = \" &lt;&lt; static_val &lt;&lt; '\\n'; // output: 10 oder 0  return 0;}The linker decides at link time which translation unit it processes first.  If it processes file1.cpp first, sum_result is initialized to 10, and static_val is also set to 10.  If it processes file2.cpp first, static_val is set to 0, and then sum_result is initialized to 10.This behavior leads to a discrepancy between the values of sum_result and static_val, even though they are logically expected to be the same.  This inconsistency is the essence of the Static Initialization Order Fiasco.The Solutionfile1.cppconstexpr auto sum(int a, int b) {  return a + b;}constinit int sum_result = sum(5, 5);Here, sum_result is initialized at compile time because the sum function is constexpr, and the values (5 and 5) are known at compile time. To enforce compile-time initialization, the constinit keyword is required.file2.cppextern constinit int sum_result; int static_val = sum_result;Because sum_result is defined in another translation unit, static_val is zero-initialized1 since the value of sum_result is not available during the compile step.main.cppextern constinit int sum_result;extern int static_val;auto main() -&gt; int {  std::cout &lt;&lt; \"sum_result = \" &lt;&lt; sum_result &lt;&lt; '\\n'; // output: 10  std::cout &lt;&lt; \"static_val = \" &lt;&lt; static_val &lt;&lt; '\\n'; // output: 10  return 0;}Now, it no longer matters which translation unit the linker processes first. static_val will always be initialized with the value 10 because sum_result is guaranteed to be initialized at compile time.ConclusionTo guarantee initialization of global or static variables at compile time:1. All values must be known at compile time2. The variable must be marked with either the constexpr or constinit keywordAlthough compilers often perform compile-time initialization without these keywords, this behavior is not guaranteed unless the keywords are explicitly used.Understanding the Static Initialization Order Fiasco not only helps avoid potential bugs but also highlights the importance of explicit initialization in C++ programming. By leveraging C++ features like constexpr and constinit, developers can ensure consistency and predictability in their applications.Share your feedbackPraise or criticism is appreciated!Footnote            Zero-initialization depends on the data type and sets the value to a null value defined by the type:              For arithmetic types (e.g., int, float), it is 0 or 0.0.        For pointers, it is nullptr.        For bool, it is false.        For characters (char), it is '\\0'.        For user-defined types (e.g., classes/structs), all members are recursively zero-initialized.            &#8617;&#xfe0e; &#8617;&#xfe0e;2      "
  },
  
  {
    "title": "'if consteval' in C++: A Better Alternative to is_constant_evaluated",
    "url": "/posts/if-consteval-in-cpp-a-better-alternative-to-is-constant-evaluated/",
    "categories": "C++, Compile-time programming",
    "tags": "c++, c++23, if-consteval, is-constant-evaluated, constexpr, consteval, compile-time, static-analysis, consteval-functions",
    "date": "2025-01-27 12:00:00 +0100",
    





    
    "snippet": "IntroductionWhen working with constexpr and consteval in C++, developers may run into some limitations when attempting to evaluate conditions at compile-time. One common scenario is using std::is_c...",
    "content": "IntroductionWhen working with constexpr and consteval in C++, developers may run into some limitations when attempting to evaluate conditions at compile-time. One common scenario is using std::is_constant_evaluated() to differentiate between compile-time and runtime code. However, there are cases where this approach fails due to how the compiler performs static analysis — leading to behavior that might be surprising at first glance.Let’s take a closer look at what can go wrong and how if consteval can help.Why Doesn’t This Code Work?Consider the following constexpr function:consteval auto consteval_func(int val) { return val; }constexpr auto constexpr_func(int val) {  if (std::is_constant_evaluated()) {    return consteval_func(val);  } else {    std::cout &lt;&lt; \"is_constant_evaluated==false\\n\";    return 0;  }}The compiler produces an error on the line (5), because the parameter val is not constexpr. A consteval function like consteval_func() can only be called with constexpr arguments.Logically, this seems unnecessary since the if (std::is_constant_evaluated()) branch will only execute at compile-time. And even though val isn’t constexpr, the constexpr function would have been invoked with a constexpr argument if executed at compile-time. For example:constexpr auto val = [] consteval { return constexpr_func(42); }();Why doesn’t it work anyway?The compiler reports an error during static analysis, even if the function is not invoked. The error arises because the compiler, during its static analysis phase, checks the code for syntactic and semantic correctness. Since an if clause is a runtime construct, the compiler does not generate separate code branches for compile-time and runtime during this phase.Instead, the compiler treats the call consteval_func(val) in the if clause as if it were outside the clause entirely. This means the call is always analyzed, regardless of whether it will actually execute or not. Consequently, the compiler raises an error because val is not constexpr.  This behavior leads to the conclusion that calling a consteval function from a constexpr function with a non-constexpr argument is always invalid.Enter if constevalHere’s how if consteval resolves the issue:consteval auto consteval_func(int val) { return val; }constexpr auto constexpr_func(int val) {  if consteval {    return consteval_func(val);  } else {    std::cout &lt;&lt; \"is_constant_evaluated==false\\n\";    return 0;  }}With if consteval, the compiler makes the decision about which branch to execute during static analysis. This means:  The consteval branch is excluded entirely from runtime evaluation.  The compiler knows that the call to consteval_func(val) happens only in a compile-time context, allowing it to validate the code confidently.Unlike an if clause, if consteval is a compile-time construct, just like if constexpr. The compiler decides which branch to execute during static analysis and excludes the other entirely. This means the compiler can safely allow the call to the consteval_func(val) function, knowing that the call will occur only in a constexpr context during compile-time.Conclusionstd::is_constant_evaluated() is useful for distinguishing between compile-time and runtime logic, but it is not suitable when working with consteval functions. The introduction of if consteval in C++ provides a cleaner and safer way to handle compile-time evaluation, ensuring that the compiler can confidently differentiate between branches.Share your feedbackPraise or criticism is appreciated!"
  }
  
]

